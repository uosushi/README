# substr
開始位置と長さを指定したら部分文字列を返す
mem++しちゃうとreturnのときずれてしまうのでiをつかう
 lenがint maxの場合も動作するようにする

# strjoin
- bzero


# strtrim
- 文字列`set`の文字いずれかにあてはまったら削除して結果を新しく確保したメモリにコピーして返す関数
- NULLチェック（!s1）
	-> トリミング対象が存在しないためNULLを返す
- NULLチェック（!set）
	-> もともとs1にNULL止め以外のNULLはないので`ft_strdup(s1)`を返す
- 「先頭と末尾から」とあるので削った結果のインデックスを取得する
	-> トリミング開始位置（start）と終了位置（end）
- ft_is_set
	-> 文字`c`が文字列`set`の文字いずれかに当てはまるかチェックする関数
	-> 当てはまるなら1、全て当てはまらないなら0を返す
- whileの中でifを書くよりwhileの条件分にしちゃった方が`break ;`もいらないしカウント用の`i`もいらなくなる
- endを計算する前か後にstrlenで全部setに当てはまってしまっていないか確認する
	-> 長さ10のときstartが(10-1), endが(0)になりかねない
- ft_substr(使用関数mallocのみ)を利用して、s1のstart位置から(end - start + 1)の長さ切り取ったものをmallocで確保してもらったメモリに代入してもらい取得する

# split
- !s
	-> NULLチェック
	-> NULL(0)であっても区切り文字に指定される可能性があるため、`!c`しない。sにNULLが出現したら終了するため無意味だが、指定可能。
- pos
	-> positionの略
	-> global変数が許されていないため、何文字まで読み込んだかの確認用にアドレスで渡している

["ABC", "DEF"]  
"ABC DEF"

ft_count 配列の長さ  
ft_split ["", ""]  
strset    ""  


DEBUG
- 配列のうちどこかで割り当てを失敗しNULLを返したとき、そこまで成功したメモリは保持されたまま。なのでいずれ来る可能性があるメモリリークを防ぐため、失敗時には配列全体のfreeが必要となる
- freeしおえたら、割り当て失敗ということでNULLを返す。2行で書くより、`return (配列をfreeする関数)`のように1行でまとめてしまうとスッキリする。


# itoa
- 長さのカウントはnがlong intでないとオーバーフローに対応できないのでlong intへ
- mallocで`size + 1`と計算するのはNULL止め用のメモリが1個いるから
- ft_int_len
	-> 正の値`n`の桁数を返す自作関数
	-> ft_itoaの引数がintであり、桁数がintを超えることはないためintを用いている
- ft_int_len(num)を足し合わせる前のsizeは符号を入れるため用に確保したい文字1個分が必要か必要でないかを判断している（そのため、size += を使って足し合わせている）
- せっかくsizeを確保してあるのと、このあとwhileでカウントダウンしてしまう予定なので、先に`dest[size] = '\0'`でNULLを入れておく
- nが負の値ならsizeが1以上まで、正の値なら0以上までカウントダウンする。
	-> 内部では`dest[size]`に対して(num % 10) + '0'を代入していく
	-> つまり（符号抜きで）小さい桁から順にdestの後ろから代入していく
	-> その後 num /= 10で小さい桁を排除しつめていく
- さいごに（必要であれば）符号をいれる

- n == -1
	-> size = 1 + 1 + 1 = 3 == '-1\0'
- n == 1
	-> size = 0 + 1 + 1 = 2 == '1\0'



# strmapi
関数ポインタについて調べた。
-- シーザー暗号見たいって教えてもらった snara くん さんに
sが空っぽでもfが空っぽでもどちらとも空っぽでもダメなのでifではorをつかってよい
明示的にやろうと考えてたけどNULL文字比較は!='\0'をわざわざ描かない方で統一する
みためすっきりするので

DEBUG
- 一時的に差し入れていたメモリサイズを適切なものへ

# putchar_fd
- ファイルディスクリプタを指定し書き込みを行う

# putstr_fd

# putendl_fd
- 最後にNULL文字いらない

# putnbr_fd
- 再帰を用いるとネストが深くなりかねないが、atoiと違いintの上限下限があるため再帰を用いることができる。
- 解説
	-> ケースによっては-1を掛け合わせ反転する（INT_MAXはINT_MINより符号を抜いた時の数が1少ない）ので、オーバーフローしないよう`long int`型にキャストしておく
	-> nが9以下なら（つまり1桁なら）`n + '0'`でchar型の数値に戻してファイルディスクリプタを指定し出力する。
- 例
	-> putnbr_fd(fd, -123);
	-> n = -123 * -1
	-> pri(fd, 123);
	-> 123 >= 10
	-> pri(fd, 123 / 10);
		-> pri(fd, 123 % 10)が保留中
	-> 12 >= 10
	-> pri(fd, 12 / 10);
		-> pri(fd, 12 % 10)が保留中
	-> 1 < 10
	-> write(fd, '1', 1);
		-> [ターミナルへの出力状態]: 1
	-> pri(fd, 12 / 10)の処理が完了したので保留されていたpri(fd, 12 % 10)が実行される
	-> 2 < 10
	-> write(fd, '2', 1);
		-> [ターミナルへの出力状態]: 12
	-> pri(fd, 123 / 10)の処理が完了したので保留されていたpri(fd, 123 % 10)が実行される
	-> 123 % 10 == 3
	-> 3 < 10
	-> write(fd, '3', 1);
		-> [ターミナルへの出力状態]: 123
	-> 全ての処理が終了！　出力は改行なしの`123`のみ！

	